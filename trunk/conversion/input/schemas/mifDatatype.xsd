<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="urn:hl7-org:v3/mif" xmlns="urn:hl7-org:v3/mif" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://www.ascc.net/xml/schematron" elementFormDefault="qualified">
	<xs:annotation>
		<xs:documentation>
********************************************************************************
Author: Initial development by Lloyd McKenzie, Dec. 2002
(c) 2002, 2003 by HL7 Inc.

Purpose:
	Provides a format for defining datatypes and their properties.

Modification History:
	2002-12-13: Added minimumSupportedLength
	2003-01-25: Changed enumeration set for property.kind
			- Removed CME coding strength
	2003-02-07: Moved definition of property kind type to internalMarkup
	2003-02-14: Require 'kind' attribute on propertyReferences as well as properties
	2003-03-18: Changed type for domainName to 'domainNameType' to allow for x_domains

Programatic rules (rules that apply but are not schema or schematron-enforced):
  - All datatypes referenced in a DatatypeDefinition must exist in the datatype model, or in one of the models in the inheritance hierarcy.
  - There can't be any duplicates of datatype name or formalName within a DatatypeModelLibrary or any of the models in the inheritance hierarchy

Outstanding questions:
  - What constraints should there be on datatypeModelLibrary.modelId?
********************************************************************************
		</xs:documentation>
	</xs:annotation>
	<xs:include schemaLocation="mifStaticBase.xsd"/>
	<xs:element name="datatypeModelLibrary" type="DatatypeModelLibrary">
		<xs:annotation>
			<xs:documentation>A datatype model</xs:documentation>
			<xs:documentation>UML: A Package with a DatatypeModel stereotype</xs:documentation>
			<xs:appinfo>
				<sch:pattern name="Validate datatypeModel element">
					<sch:rule context="mif:datatypeModel">
						<sch:extends rule="DatatypeModel"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="DatatypeModelLibrary">
		<xs:annotation>
			<xs:documentation>A container for datatype definitions</xs:documentation>
			<xs:documentation>UML: DatatypeModelLibrary stereotype.</xs:documentation>
			<xs:appinfo>
				<sch:pattern name="Validate DatatypeModel type">
					<sch:rule abstract="true" id="DatatypeModelLibrary">
						<sch:extends rule="Package"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Package">
				<xs:sequence>
					<xs:element name="derivationSupplier" type="PackageDerivation" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Identifies the package(s) from which the current package was derived.</xs:documentation>
							<xs:documentation>UML: supplier association from ModelElement to Derivation stereotype on Dependency</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="supplierImportDatatypeModelLibrary" type="ImportDatatypeModelLibrary" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Identifies any datatype models that are extended by the current model</xs:documentation>
							<xs:documentation>UML: supplier association to Import stereotype of a Permission dependency to another DatatypeModelLibrary</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ownedDatatype" type="Datatype" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Lists all of the datatypes defined in the current model, as well as those referenced from one of the inherited models.</xs:documentation>
							<xs:documentation>UML: The ownedElement relationship to the DatatypeDefinitions in the package</xs:documentation>
							<xs:appinfo>
								<sch:pattern name="Validate ownedDatatype element">
									<sch:rule context="mif:ownedDatatype">
										<sch:extends rule="Datatype"/>
									</sch:rule>
								</sch:pattern>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ImportDatatypeModelLibrary">
		<xs:annotation>
			<xs:documentation>Identifies the DatatypeModelLibrary package being imported, as well as identifying all datatypes that are to be publicly exposed from the imported model.  (Default is 'private' exposure for those datatypes not explicitly mentioned.)</xs:documentation>
			<xs:documentation>UML: Represents a combination of the Import stereotype to another DatatypeModelLibrary (via the packageref), as well as the ElementImport association to each imported datatype</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="PackageRef">
				<xs:sequence>
					<xs:element name="importedDatatype" type="DatatypeImport" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Identifies those datatypes that should be 'exposed' in the current datatype model.  Exposed datatypes will be usable as attribute datatypes.  All datatypes will be accessible for 'refinement'.</xs:documentation>
							<xs:documentation>UML: The ElementImport association to each datatype being imported</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DatatypeImport">
		<xs:annotation>
			<xs:documentation>UML: Corresponds to ElementImport class association pointing to an imported datatype</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DatatypeRef">
				<xs:attribute name="visibility" type="VisibilityKind" use="required" fixed="public">
					<xs:annotation>
						<xs:documentation>Indicates that the imported datatype should be made 'public' in this datatype model</xs:documentation>
						<xs:documentation>UML: ElementImport.visibility</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Datatype">
		<xs:annotation>
			<xs:documentation>The definition of a structure for transmitting and persisting fundamental concepts within a model.</xs:documentation>
			<xs:documentation>UML: DatatypeDefinition stereotype</xs:documentation>
			<xs:appinfo>
				<sch:pattern name="Validate Datatype type">
					<sch:rule abstract="true" id="Datatype">
						<sch:report test="count(preceding::mif:*[name(.)=name(current())][@name=current()/@name][count(mif:parameter[@name=current()/mif:parameter/@name])=count(mif:parameter)])!=0">
							ERROR: There must not be more than one datatype definition having the same name and parameters.</sch:report>
						<sch:report test="ancestor::mif:datatypeModelLibrary//*[name(.)=name(current())][@name=current()/@name]&gt;1">
							ERROR: There cannot be more than one datatype with the same name.</sch:report>
						<sch:report test="count(mif:operation)!=0 and count(mif:specializationChildDatatype)!=0">
							ERROR: A datatype may have specializations or operations, but not both.</sch:report>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Classifier">
				<xs:sequence>
					<xs:element name="derivationSupplier" type="DatatypeDerivation" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Identifies the datatype(s) from which the current datatype was derived.</xs:documentation>
							<xs:documentation>UML: supplier association from ModelElement to Derivation stereotype on Dependency</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="graphicRepresentation" type="NodeSemanticModelBridge" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Indicates the display shape(s) associated with the datatype definition</xs:documentation>
							<xs:documentation>UML: association from ModelElement to SemanticModelBridge</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="annotations" type="DatatypeAnnotations" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Descriptive information about the containing element.</xs:documentation>
							<xs:documentation>UML: A collector for the comments and constraints associated with a model element.  (Consider rendering the definition or description annotation into ModelElement.documentation)</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="supplierBinding" type="DatatypeBinding" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Identifies a parameterized datatype for which this datatype is an 'instantiation'</xs:documentation>
							<xs:documentation>UML: Indicates the supplier binding dependency for the datatype</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ownedDatatype" type="Datatype" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A datatype defined to exist only within the context of it's parent datatype.  (Generally used for protected or private types.)</xs:documentation>
							<xs:documentation>UML: Classifiers can 'own' other classifiers because they descend from package.  Datatype prohibits this in 1.4, so we'll use a Class underlying the stereotype where we want to do this instead of a </xs:documentation>
							<xs:appinfo>
								<sch:pattern name="Validate ownedDatatype element">
									<sch:rule context="mif:ownedDatatype">
										<sch:extends rule="Datatype"/>
									</sch:rule>
								</sch:pattern>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
					<xs:element name="specializationChildDatatype" type="DatatypeRef" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A reference to a specialized version of the current datatype that may be substituted in its place.</xs:documentation>
							<xs:documentation>UML: Walking the Generalization of the Datatype Classifier</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="operation" type="DatatypeOperation" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A capability of a datatype.</xs:documentation>
							<xs:documentation>UML: feature association to a DatatypeOperation stereotype</xs:documentation>
							<xs:appinfo>
								<sch:pattern name="Validate operation element">
									<sch:rule context="mif:operation">
										<sch:extends rule="DatatypeOperation"/>
									</sch:rule>
								</sch:pattern>
							</xs:appinfo>
						</xs:annotation>
						<xs:unique name="parameterNameUniqueInProperty">
							<xs:selector xpath="parameter"/>
							<xs:field xpath="@name"/>
						</xs:unique>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="name" type="DatatypeName" use="required">
					<xs:annotation>
						<xs:documentation>The formal identifier associated with the datatype.</xs:documentation>
						<xs:documentation>UML: inherited from modelElement.name</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="title" type="BasicFormalName" use="required">
					<xs:annotation>
						<xs:documentation>The descriptive name associated with the datatype.</xs:documentation>
						<xs:documentation>UML: title tag on Datatype stereotype</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="visibility" type="VisibilityKind" use="required">
					<xs:annotation>
						<xs:documentation>Identifies the amount of exposure the datatype has.</xs:documentation>
						<xs:documentation>UML: Inherits from modelElement.visibility.  Restricted to private, protected or public.  ('Package' is not allowed)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DatatypeBinding">
		<xs:annotation>
			<xs:documentation>Identifies the parameterized datatype being 'instatntiated', as well as the types to use for each parameter</xs:documentation>
			<xs:documentation>UML: The binding dependency that links to the datatype that the current datatype binds to</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="targetDatatype" type="DatatypeRef">
				<xs:annotation>
					<xs:documentation>The parameterized datatype that this definition 'instantiates'</xs:documentation>
					<xs:documentation>UML: Datatype that is the target of the binding dependency</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="argumentDatatype" type="DatatypeRef" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>The parameterized datatype that this definition 'instantiates'</xs:documentation>
					<xs:documentation>UML: Datatype that is the argument model element for the binding dependency</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DatatypeAnnotations">
		<xs:annotation>
			<xs:documentation>Comments relating to the datatype model</xs:documentation>
			<xs:documentation>UML: A collector for the comments and constraints associated with a Datatype.  (Consider rendering the definition or description annotation into ModelElement.documentation)</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="Annotations">
				<xs:sequence>
					<xs:group ref="Definition"/>
					<xs:group ref="UsageNotes"/>
					<xs:group ref="Rationale"/>
					<xs:group ref="DesignComments"/>
					<xs:group ref="Mapping"/>
					<xs:group ref="Constraint"/>
					<xs:group ref="BallotComment"/>
					<xs:group ref="OtherAnnotation"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DatatypeDerivation">
		<xs:annotation>
			<xs:documentation>UML: A derivation dependency to another datatype</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Derivation">
				<xs:sequence>
					<xs:element name="targetDatatype" type="DatatypeRef">
						<xs:annotation>
							<xs:documentation>Identifies the datatype from which the current type is derived.</xs:documentation>
							<xs:documentation>UML: supplier of Derivation dependency stereotype</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BehavioralFeature">
		<xs:annotation>
			<xs:documentation>Base class for methods and datatype operations</xs:documentation>
			<xs:documentation>UML: Corresponds to BehavioralFeature</xs:documentation>
			<xs:appinfo>
				<sch:pattern name="Validate BehavioralFeature type">
					<sch:rule abstract="true" id="BehavioralFeature">
						<sch:extends rule="Feature"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Feature">
				<xs:sequence>
					<xs:element name="parameter" type="Parameter" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A parameter passed to the property used in determining the value for the property.</xs:documentation>
							<xs:documentation>UML: Parameter of 'input' type</xs:documentation>
						</xs:annotation>
						<!-- Todo: Consider having defaults for parameter  -->
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Parameter">
		<xs:annotation>
			<xs:documentation>UML: Corresponds to 'Parameter' for an operation that takes a datatype as it's argument.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelElement">
				<xs:sequence>
					<xs:element name="type" type="DatatypeRef">
						<xs:annotation>
							<xs:documentation>Identifies the datatype of the property</xs:documentation>
							<xs:documentation>UML: Parameter.type association</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="name" type="FormalProperName" use="optional">
					<xs:annotation>
						<xs:documentation>The name of the parmater as referenced by code or by formal constraints.</xs:documentation>
						<xs:documentation>UML: from Parameter, inherited from modelElement</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Operation">
		<xs:annotation>
			<xs:documentation>UML: Corresponds to 'Operation'</xs:documentation>
			<xs:appinfo>
				<sch:pattern name="Validate Operation type">
					<sch:rule abstract="true" id="Operation">
						<sch:extends rule="BehavioralFeature"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BehavioralFeature"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DatatypeOperation">
		<xs:annotation>
			<xs:documentation>Defines the content for a datatypeOperation</xs:documentation>
			<xs:documentation>UML: The basic part of the DatatypeOperation stereotype</xs:documentation>
			<xs:appinfo>
				<sch:pattern name="Validate DatatypeOperation type">
					<sch:rule abstract="true" id="DatatypeOperation">
						<sch:extends rule="Operation"/>
						<extends rule="CodeValidation"/>
						<sch:report test="@operationKind!='conversion' and count(preceding-sibling::mif:*[name(.)=name(current())][@name=current()/@name][count(mif:parameter[@name=current()/mif:parameter/@name])=count(mif:parameter)]">
							ERROR: There must not be more than one operation within a datatype definition having the same name and parameters.</sch:report>
						<sch:report test="@defaultFrom and count(mif:type/descendant-or-self::mif:*[contains('CD;CE;CS;SC;BL;ST;INT;REAL;MO;PQ', @name)])!=1">
							WARNING: DefaultFrom may only be specified for codes and simple datatypes (CD, CE, CS, SC, BL, ST, INT, REAL, MO, PQ).</sch:report>
						<sch:report test="count(mif:supplierDomainSpecification)=0 and count(mif:type/descendant-or-self::mif:*[contains('CD;CE;CS;SC', @name)])!=0">
							WARNING: Domain must be present for coded types (CD, CE, CS and SC).</sch:report>
						<sch:report test="count(mif:supplierDomainSpecification)!=0 and count(mif:type/descendant-or-self::mif:*[contains('CD;CE;CS;SC', @name)])=0">
							WARNING: Domain may only be present for coded types (CD, CE, CS and SC).</sch:report>-->
						<sch:report test="@default and count(mif:type/descendant-or-self::mif:*[contains('CD;CE;CS;SC;BL;ST;INT;REAL;MO;PQ', @name)])!=1">
							WARNING: Default may only be specified for codes and simple datatypes (CD, CE, CS, SC, BL, ST, INT, REAL, MO, PQ).</sch:report>
						<sch:report test="@minimumSupportedLength and count(mif:type/descendant-or-self::mif:*[contains('CD;CE;CS;SC;BL;ST;INT;REAL;MO;PQ', @name)])!=1">
							WARNING: Minimum supported length may only be specified for codes and simple datatypes (CD, CE, CS, SC, BL, ST, INT, REAL, MO, PQ).</sch:report>
						<sch:report test="count(mif:type/descendant-or-self::mif:*[@name='CS'])!=0 and mif:supplierDomainSpecification/@codingStrength='CWE'">
							ERROR: CodingStrength must not be CWE for CS datatype attributes.</sch:report>
						<sch:report test="count(mif:derivationSupplier)=0 and count(mif:businessName)=0">
							ERROR: Non-derived operations must have a business name.</sch:report>
						<!-- How come? . . . -->
						<sch:report test="count(mif:derivationSupplier)=0 and count(mif:annotations/mif:definition)=0">
							ERROR: Non-derived operations must have a definition annotation.</sch:report>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Operation">
				<xs:sequence>
					<xs:element name="annotations" type="OperationAnnotations" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Descriptive information about the containing element.</xs:documentation>
							<xs:documentation>UML: Inherited from modelElement</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="derivationSupplier" type="OperationDerivation" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Identifies the property and the datatype from which the current property is derived.</xs:documentation>
							<xs:documentation>UML: Property with a derivedFrom dependency</xs:documentation>
							<xs:appinfo>
								<sch:pattern name="Validate derivationSupplier element">
									<sch:rule context="mif:operation/mif:derivationSupplier">
										<sch:extends rule="OperationDerivation"/>
									</sch:rule>
								</sch:pattern>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
					<xs:element name="type" type="DatatypeRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Identifies the type of the data exposed by the property.</xs:documentation>
							<xs:documentation>UML: return type of 'typed' BehavioralFeature</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="supplierDomainSpecification" type="DomainSpecificationWithStrength" minOccurs="0">
						<xs:annotation>
							<xs:documentation>References the HL7 vocabulary to define the set of allowed values that may be conveyed by this property.</xs:documentation>
							<xs:documentation>UML: Association to the vocabularyDomain - need to figure out what association</xs:documentation>
							<xs:appinfo>
								<sch:pattern name="Validate supplierDomainSpecification element">
									<sch:rule context="mif:supplierDomainSpecification">
										<sch:extends rule="DomainSpecificationWithStrength"/>
									</sch:rule>
								</sch:pattern>
							</xs:appinfo>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="operationKind" type="DatatypeOperationKind" use="required">
					<xs:annotation>
						<xs:documentation>Identifies the variety of property being represented.  This attribute influences how the property is represented for display purposes in documentation.</xs:documentation>
						<xs:documentation>UML: Tagged value on datatypeProperty</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="name" type="FormalPropertyName" use="optional">
					<xs:annotation>
						<xs:documentation>Name of the property</xs:documentation>
						<xs:documentation>UML: Name inherited from DataElement</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OperationDerivation">
		<xs:annotation>
			<xs:documentation>UML: A derivation dependency on another datatype operation</xs:documentation>
			<xs:appinfo>
				<sch:pattern name="Validate OperationDerivation type">
					<sch:rule abstract="true" id="OperationDerivation">
						<sch:report test="@operationName and count(mif:type)!=0">
							ERROR: A property reference may only have a name or a conversion datatype, not both.</sch:report>
						<sch:report test="not(@operationName) and count(mif:type)=0">
							ERROR: A property reference must have either a name or a conversion datatype.</sch:report>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="Derivation">
				<xs:sequence>
					<xs:element name="type" type="DatatypeRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>For 'conversion' properties, identifies the target datatype for the conversion.</xs:documentation>
							<xs:documentation>UML: result type of the operation.  Used for referencing non-named 'conversion' operations</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="targetDatatype" type="DatatypeRef">
						<xs:annotation>
							<xs:documentation>Identifies the datatype from which the property is derived.</xs:documentation>
							<xs:documentation>UML: client association on the derivedFrom dependency</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="operationName" type="FormalPropertyName" use="optional">
					<xs:annotation>
						<xs:documentation>The name of the operation in the identified datatype on which this property is based.</xs:documentation>
						<xs:documentation>UML: name as inherited from DataElement</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DatatypeTemplateParameter">
		<xs:annotation>
			<xs:documentation>UML: TemplateParameter for a datatype</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DatatypeRef">
				<xs:attribute name="parameterName" type="FormalProperName" use="required">
					<xs:annotation>
						<xs:documentation>The name of the parameter for use in describing the datatype or in constructing formal constraints.</xs:documentation>
						<xs:documentation>UML: Name tag on TemplateParameter stereotype</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OperationAnnotations">
		<xs:annotation>
			<xs:documentation>Comments relating to the operation</xs:documentation>
			<xs:documentation>UML: A collector for the comments and constraints associated with a Datatype operation.  (Consider rendering the definition or description annotation into ModelElement.documentation)</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="Annotations">
				<xs:sequence>
					<xs:group ref="Definition"/>
					<xs:group ref="UsageNotes"/>
					<xs:group ref="Rationale"/>
					<xs:group ref="DesignComments"/>
					<xs:group ref="Mapping"/>
					<xs:group ref="Constraint"/>
					<xs:group ref="BallotComment"/>
					<xs:group ref="OtherAnnotation"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
</xs:schema>
